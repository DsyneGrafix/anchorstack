// advanced-vault-automation.ts
import * as fs from 'fs';
import * as path from 'path';

interface VaultItem {
  filename: string;
  title: string;
  description: string;
  tier: string;
  value: string;
  category: string;
  filePath: string;
  htmlPath?: string;
  originalPath?: string;
  autoGenerated?: boolean;
}

interface TierConfig {
  value: string;
  folder: string;
  badge: string;
  color: string;
}

const tierConfigs: Record<string, TierConfig> = {
  freebies: { 
    value: "FREE", 
    folder: "freebies", 
    badge: "🎁 FREE",
    color: "green"
  },
  bronze: { 
    value: "$15", 
    folder: "bronze", 
    badge: "🥉 BRONZE",
    color: "orange"
  },
  silver: { 
    value: "$35", 
    folder: "silver", 
    badge: "🥈 SILVER", 
    color: "blue"
  },
  gold: { 
    value: "$75", 
    folder: "gold", 
    badge: "🥇 GOLD",
    color: "yellow"
  },
  platinum: { 
    value: "$150", 
    folder: "platinum", 
    badge: "💎 PLATINUM",
    color: "purple"
  }
};

class VaultAutomationSystem {
  private vaultPath = './public/vault-content';
  private indexPath = './public/vault-content/vault-index.json';
  private tilesOutputPath = './src/data/vault-tiles.json';
  private htmlTemplatesPath = './templates';

  constructor() {
    this.ensureDirectories();
  }

  private ensureDirectories() {
    if (!fs.existsSync(this.vaultPath)) {
      fs.mkdirSync(this.vaultPath, { recursive: true });
    }
    
    // Create tier folders
    Object.values(tierConfigs).forEach(config => {
      const tierPath = path.join(this.vaultPath, config.folder);
      if (!fs.existsSync(tierPath)) {
        fs.mkdirSync(tierPath, { recursive: true });
      }
    });

    // Create templates directory
    if (!fs.existsSync(this.htmlTemplatesPath)) {
      fs.mkdirSync(this.htmlTemplatesPath, { recursive: true });
      this.createDefaultTemplate();
    }
  }

  private createDefaultTemplate() {
    const template = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}} | AnchorStack Vault</title>
    <meta name="description" content="{{description}}">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #000;
            background-color: #fff;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .product-header {
            text-align: center;
            background: linear-gradient(135deg, {{gradientStart}} 0%, {{gradientEnd}} 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }
        .tier-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: {{badgeColor}};
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            font-weight: 700;
            font-size: 0.9rem;
        }
        .product-title {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }
        .product-description {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 1rem;
        }
        .download-section {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            margin: 2rem 0;
        }
        .download-btn {
            background: white;
            color: #4caf50;
            padding: 1rem 2rem;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            margin: 0.5rem;
            transition: transform 0.2s;
        }
        .download-btn:hover {
            transform: translateY(-2px);
        }
        .content-preview {
            background: #f8f9fa;
            border-left: 4px solid {{accentColor}};
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 4px;
        }
        @media (max-width: 600px) {
            .product-title { font-size: 2rem; }
        }
    </style>
</head>
<body>

<div class="product-header">
    <div class="tier-badge">{{tierBadge}}</div>
    <h1 class="product-title">{{title}}</h1>
    <p class="product-description">{{description}}</p>
    <div class="pricing">{{value}}</div>
</div>

<div class="content-preview">
    <h3>What You Get:</h3>
    {{contentPreview}}
</div>

<div class="download-section">
    <h3>Ready to Get Started?</h3>
    <p>Download starts immediately. {{downloadInstructions}}</p>
    <a href="{{downloadUrl}}" class="download-btn" download>
        📥 Download {{title}}
    </a>
</div>

<footer style="text-align:center; font-size: 0.85rem; color: #333; margin-top: 2rem;">
    © Copyright AnchorStack.pro 2025 — All rights reserved. <br>
    Part of the CreatorOS Wisdom Vault Initiative.
</footer>

</body>
</html>`;

    fs.writeFileSync(path.join(this.htmlTemplatesPath, 'vault-item-template.html'), template);
  }

  private loadExistingIndex(): Record<string, VaultItem> {
    if (fs.existsSync(this.indexPath)) {
      try {
        const data = fs.readFileSync(this.indexPath, 'utf-8');
        return JSON.parse(data);
      } catch (error) {
        console.warn('Could not parse existing vault index, creating new one');
      }
    }
    return {};
  }

  private scanAllFiles(): string[] {
    const allFiles: string[] = [];
    
    const scanDirectory = (dir: string) => {
      const items = fs.readdirSync(dir);
      
      items.forEach(item => {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          scanDirectory(fullPath);
        } else if (this.isValidVaultFile(item)) {
          allFiles.push(fullPath);
        }
      });
    };

    scanDirectory(this.vaultPath);
    return allFiles;
  }

  private isValidVaultFile(filename: string): boolean {
    const validExtensions = ['.pdf', '.docx', '.txt', '.md', '.html', '.zip'];
    const ext = path.extname(filename).toLowerCase();
    return validExtensions.includes(ext) && !filename.startsWith('.');
  }

  private determineFileCategory(filename: string, filePath: string): string {
    const name = filename.toLowerCase();
    const pathLower = filePath.toLowerCase();
    
    // Category detection logic
    if (name.includes('template') || name.includes('worksheet')) return 'Templates';
    if (name.includes('course') || name.includes('lesson')) return 'Courses';
    if (name.includes('guide') || name.includes('strategy')) return 'Guides';
    if (name.includes('journal') || name.includes('planner')) return 'Planners';
    if (name.includes('checklist') || name.includes('tracker')) return 'Tools';
    if (pathLower.includes('art') || name.includes('design')) return 'Design';
    
    return 'Resources';
  }

  private autoDetectTier(filePath: string): string {
    const pathLower = filePath.toLowerCase();
    
    // Check if file is already in a tier folder
    for (const [tierKey, config] of Object.entries(tierConfigs)) {
      if (pathLower.includes(`/${config.folder}/`)) {
        return tierKey;
      }
    }
    
    // Default tier detection based on path or filename
    if (pathLower.includes('/courses/') || pathLower.includes('course')) return 'gold';
    if (pathLower.includes('/premium/') || pathLower.includes('pro')) return 'silver';
    if (pathLower.includes('/free/') || pathLower.includes('starter')) return 'freebies';
    
    return 'bronze'; // Default tier
  }

  private moveFileToCorrectTier(currentPath: string, targetTier: string): string {
    const filename = path.basename(currentPath);
    const targetFolder = tierConfigs[targetTier].folder;
    const newPath = path.join(this.vaultPath, targetFolder, filename);
    
    // Only move if not already in correct location
    if (currentPath !== newPath && fs.existsSync(currentPath)) {
      console.log(`📦 Moving ${filename} to ${targetTier} tier`);
      
      // Ensure target directory exists
      const targetDir = path.dirname(newPath);
      if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
      }
      
      // Move the file
      fs.renameSync(currentPath, newPath);
      return newPath;
    }
    
    return currentPath;
  }

  private generateHtmlPromoPage(item: VaultItem): string {
    const template = fs.readFileSync(
      path.join(this.htmlTemplatesPath, 'vault-item-template.html'), 
      'utf-8'
    );
    
    const tierConfig = tierConfigs[item.tier.toLowerCase()];
    const colors = this.getTierColors(item.tier.toLowerCase());
    
    const contentPreview = this.generateContentPreview(item);
    const downloadInstructions = item.tier === 'freebies' ? 
      'No email required.' : 
      'Purchase includes lifetime access.';
    
    const html = template
      .replace(/{{title}}/g, item.title)
      .replace(/{{description}}/g, item.description)
      .replace(/{{tierBadge}}/g, tierConfig.badge)
      .replace(/{{value}}/g, item.value)
      .replace(/{{gradientStart}}/g, colors.gradientStart)
      .replace(/{{gradientEnd}}/g, colors.gradientEnd)
      .replace(/{{badgeColor}}/g, colors.badgeColor)
      .replace(/{{accentColor}}/g, colors.accentColor)
      .replace(/{{contentPreview}}/g, contentPreview)
      .replace(/{{downloadInstructions}}/g, downloadInstructions)
      .replace(/{{downloadUrl}}/g, item.filePath);
    
    const htmlFilename = `${path.parse(item.filename).name}.html`;
    const htmlPath = path.join(path.dirname(item.filePath), htmlFilename);
    
    fs.writeFileSync(htmlPath, html);
    console.log(`🎨 Generated promo page: ${htmlFilename}`);
    
    return htmlPath;
  }

  private getTierColors(tier: string) {
    const colorMap = {
      freebies: {
        gradientStart: '#4caf50',
        gradientEnd: '#45a049',
        badgeColor: '#2e7d32',
        accentColor: '#4caf50'
      },
      bronze: {
        gradientStart: '#ff9800',
        gradientEnd: '#f57c00',
        badgeColor: '#e65100',
        accentColor: '#ff9800'
      },
      silver: {
        gradientStart: '#2196f3',
        gradientEnd: '#1976d2',
        badgeColor: '#1565c0',
        accentColor: '#2196f3'
      },
      gold: {
        gradientStart: '#ffc107',
        gradientEnd: '#ff8f00',
        badgeColor: '#ff6f00',
        accentColor: '#ffc107'
      },
      platinum: {
        gradientStart: '#9c27b0',
        gradientEnd: '#7b1fa2',
        badgeColor: '#6a1b9a',
        accentColor: '#9c27b0'
      }
    };
    
    return colorMap[tier] || colorMap.bronze;
  }

  private generateContentPreview(item: VaultItem): string {
    // Generate preview based on category and tier
    const previews = {
      'Templates': '<ul><li>📋 Professionally designed template</li><li>📝 Easy-to-follow instructions</li><li>🎨 Customizable for your needs</li></ul>',
      'Courses': '<ul><li>🎓 Step-by-step video lessons</li><li>📚 Downloadable resources</li><li>✅ Practical exercises and worksheets</li></ul>',
      'Guides': '<ul><li>📖 Comprehensive written guide</li><li>💡 Expert strategies and tips</li><li>🔧 Actionable implementation steps</li></ul>',
      'Planners': '<ul><li>📅 Daily/weekly planning pages</li><li>🎯 Goal-setting frameworks</li><li>📊 Progress tracking tools</li></ul>',
      'Tools': '<ul><li>⚡ Ready-to-use tools</li><li>📋 Checklists and trackers</li><li>🔄 Reusable templates</li></ul>'
    };
    
    return previews[item.category] || '<ul><li>📦 High-quality digital content</li><li>💼 Professional resources</li><li>🚀 Immediate access</li></ul>';
  }

  private createVaultTiles(vaultIndex: Record<string, VaultItem>) {
    const tiles = Object.values(vaultIndex).map(item => ({
      id: path.parse(item.filename).name,
      title: item.title,
      description: item.description,
      tier: item.tier,
      value: item.value,
      category: item.category,
      downloadUrl: item.filePath,
      promoUrl: item.htmlPath,
      autoGenerated: item.autoGenerated || false
    }));
    
    fs.writeFileSync(this.tilesOutputPath, JSON.stringify(tiles, null, 2));
    console.log(`🎯 Generated ${tiles.length} vault tiles`);
  }

  public async processVault(options: {
    allowFileMoving?: boolean,
    generatePromoPages?: boolean,
    updateTiers?: boolean
  } = {}) {
    console.log('🚀 Starting Advanced Vault Automation...');
    
    const existingIndex = this.loadExistingIndex();
    const allFiles = this.scanAllFiles();
    const newIndex: Record<string, VaultItem> = {};
    
    console.log(`📁 Found ${allFiles.length} files to process`);
    
    for (const filePath of allFiles) {
      const filename = path.basename(filePath);
      const existing = existingIndex[filename];
      
      // Determine tier - manual override takes precedence
      let tier: string;
      if (existing?.tier && options.updateTiers !== true) {
        tier = existing.tier; // Keep manual tier setting
      } else {
        tier = this.autoDetectTier(filePath); // Auto-detect
      }
      
      // Move file to correct tier folder if enabled
      let finalPath = filePath;
      if (options.allowFileMoving) {
        finalPath = this.moveFileToCorrectTier(filePath, tier);
      }
      
      // Create vault item
      const item: VaultItem = {
        filename,
        title: existing?.title || this.generateTitle(filename),
        description: existing?.description || this.generateDescription(filename),
        tier,
        value: tierConfigs[tier]?.value || '$0',
        category: existing?.category || this.determineFileCategory(filename, finalPath),
        filePath: finalPath.replace('./public', ''), // Web-relative path
        originalPath: filePath !== finalPath ? filePath : undefined,
        autoGenerated: !existing // Mark if this is new
      };
      
      // Generate HTML promo page if enabled
      if (options.generatePromoPages) {
        try {
          item.htmlPath = this.generateHtmlPromoPage(item).replace('./public', '');
        } catch (error) {
          console.warn(`⚠️ Could not generate promo page for ${filename}:`, error.message);
        }
      }
      
      newIndex[filename] = item;
    }
    
    // Save updated index
    fs.writeFileSync(this.indexPath, JSON.stringify(newIndex, null, 2));
    console.log(`💾 Updated vault index with ${Object.keys(newIndex).length} items`);
    
    // Generate vault tiles for frontend
    this.createVaultTiles(newIndex);
    
    // Generate summary report
    this.generateReport(newIndex);
    
    console.log('✅ Vault automation complete!');
  }

  private generateTitle(filename: string): string {
    return path.parse(filename).name
      .replace(/[_-]/g, ' ')
      .replace(/\b\w/g, l => l.toUpperCase())
      .replace(/\.(pdf|docx|txt|md|html|zip)$/i, '');
  }

  private generateDescription(filename: string): string {
    const name = filename.toLowerCase();
    
    if (name.includes('template')) return 'Professional template to streamline your workflow and boost productivity.';
    if (name.includes('course')) return 'Comprehensive course with step-by-step guidance and practical exercises.';
    if (name.includes('guide')) return 'Expert guide with proven strategies and actionable insights.';
    if (name.includes('journal')) return 'Thoughtfully designed journaling system for reflection and growth.';
    if (name.includes('planner')) return 'Strategic planning tool to organize your goals and maximize results.';
    if (name.includes('checklist')) return 'Comprehensive checklist to ensure nothing falls through the cracks.';
    if (name.includes('tracker')) return 'Powerful tracking system to monitor progress and maintain momentum.';
    
    return 'High-quality resource designed to support your personal and professional growth.';
  }

  private generateReport(vaultIndex: Record<string, VaultItem>) {
    const stats = {
      total: Object.keys(vaultIndex).length,
      byTier: {} as Record<string, number>,
      byCategory: {} as Record<string, number>,
      newItems: 0,
      withPromoPages: 0
    };
    
    Object.values(vaultIndex).forEach(item => {
      // Count by tier
      stats.byTier[item.tier] = (stats.byTier[item.tier] || 0) + 1;
      
      // Count by category
      stats.byCategory[item.category] = (stats.byCategory[item.category] || 0) + 1;
      
      // Count new items
      if (item.autoGenerated) stats.newItems++;
      
      // Count promo pages
      if (item.htmlPath) stats.withPromoPages++;
    });
    
    console.log('\n📊 VAULT AUTOMATION REPORT');
    console.log('========================');
    console.log(`Total Items: ${stats.total}`);
    console.log(`New Items Added: ${stats.newItems}`);
    console.log(`Promo Pages Generated: ${stats.withPromoPages}`);
    
    console.log('\nBy Tier:');
    Object.entries(stats.byTier).forEach(([tier, count]) => {
      const config = tierConfigs[tier];
      console.log(`  ${config?.badge || tier}: ${count} items (${config?.value || 'Unknown'})`);
    });
    
    console.log('\nBy Category:');
    Object.entries(stats.byCategory).forEach(([category, count]) => {
      console.log(`  ${category}: ${count} items`);
    });
  }
}

// CLI Interface
if (import.meta.url === `file://${process.argv[1]}`) {
  
  const args = process.argv.slice(2);
  const options = {
    allowFileMoving: args.includes('--move-files'),
    generatePromoPages: args.includes('--generate-pages'),
    updateTiers: args.includes('--update-tiers')
  };
  
  console.log('Advanced Vault Automation System');
  console.log('Options:', options);
  
 const automation = new VaultAutomationSystem();
automation.processVault(options)
    .then(() => {
      console.log('\n🎉 Automation completed successfully!');
      console.log('\nNext steps:');
      console.log('1. Review the generated vault-index.json');
      console.log('2. Check the vault-tiles.json for frontend integration');
      console.log('3. Manually edit any titles/descriptions that need refinement');
      console.log('4. Run again with --update-tiers to refresh auto-detected tiers');
    })
    .catch(error => {
      console.error('❌ Automation failed:', error);
      process.exit(1);
    });
}

export default VaultAutomationSystem;
